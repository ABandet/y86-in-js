import { Sim } from "./sim"
import { registers_enum } from "./registers"
import { Memory } from "./memory"

// Used at compile-time and for unit tests
import * as hcl from "./hcl"

function fetch(sim : Sim) {
    let valp = sim.context.pc
    let byte = sim.memory.readByte(valp)
    valp++
    
    sim.context.icode = Memory.HI4(byte)
    sim.context.ifun = Memory.LO4(byte)

    if(hcl.call("gen_need_regids")) {
        byte = sim.memory.readByte(valp)
        valp++

        sim.context.ra = Memory.HI4(byte)
        sim.context.rb = Memory.LO4(byte)
    } else {
        sim.context.ra = registers_enum.none
        sim.context.rb = registers_enum.none
    }

    if(hcl.call("gen_need_valC")) {
        sim.context.valC = sim.memory.readWord(valp)
        valp += Memory.WORD_SIZE
    } else {
        sim.context.valC = 0
    }

    // TODO : status (AOK, STOP, etc...)
    // TODO : Manage exceptions (errors can happen while accessing memory)
    // TODO : Edit hcl2js to generate a TS file instead of a JS one. If not,
    //        we'll not be able to perform any call to HCL functions from here.
}

/**
 * Decode stage. Update srcA, srcB, dstE and dstM values, depending of function generated by hcl.
 * @param sim
 */
function decode(sim : Sim) {
    sim.context.srcA = hcl.call("gen_srcA");
    if (sim.context.srcA != registers_enum.none) {
        sim.context.valA = sim.registers.read(sim.context.srcA);
    }
    else {
        sim.context.valA = 0;
    }

    sim.context.srcB = hcl.call("gen_srcB");
    if (sim.context.srcB != registers_enum.none) {
        sim.context.valB = sim.registers.read(sim.context.srcB);
    }
    else {
        sim.context.valB = 0;
    }

    sim.context.dstE = hcl.call("gen_dstE");
    sim.context.dstM = hcl.call("gen_dstM");
}

/**
 * Execute stage. Call alu_compute function.
 * @param sim
 */
function execute(sim : Sim) {
    sim.context.aluA = hcl.call("gen_aluA");
    sim.context.aluB = hcl.call("gen_aluB");
    let alu_fun = hcl.call("gen_alufun");

    // compute in valE from aluA and aluB
    try {
        sim.context.valE = sim.alu.compute_alu(sim.context.aluA, sim.context.aluB, alu_fun);
    }
    catch (e) {
        console.log("Cannot compute in alu : " + e);
    }

    // Set flags
    if (hcl.call("gen_set_cc")) {
        sim.alu.compute_cc(sim.context.aluA, sim.context.aluB, alu_fun);
    }

    //TODO : Conditional branch
}

/**
 * Memory stage. Decide whenever it need to write or read in memory. Both can't be done in one cycle in this
 * implementation of the y86.
 * @param sim
 */
function memory(sim : Sim) {
    let mem_addr = hcl.call("gen_mem_addr");
    let mem_data = hcl.call("gen_mem_data");

    if (hcl.call("gen_mem_read")) {
        try {
            sim.context.valM = sim.memory.readWord(mem_addr);
        }
        catch (e) {
            console.log("error in stage memory: " + e);
        }
    }

    else if (hcl.call("gen_mem_write")) {
        try {
            sim.memory.writeWord(mem_addr, mem_data);
        }
        catch (e) {
            console.log("error in stage memory: " + e);
        }
    }

    //TODO : Status gestion
}

/**
 * Write back stage. Uses dstE to find the register where to write the value in valE. Same for dstM.
 * Only if the register stored in dstE and/or dstM is not the special register 'none'.
 *
 * dstM and dstE were previously assigned in decode stage.
 * @param sim
 */
function writeBack(sim : Sim) {
    if (sim.context.dstE != registers_enum.none) {
        let valE = sim.context.valE;
        sim.registers.write(sim.context.dstE, valE);
    }

    if (sim.context.dstM != registers_enum.none) {
        let valM = sim.context.valM;
        sim.registers.write(sim.context.dstM, valM);
    }
}

function updatePC(sim : Sim) {
    sim.context.pc = hcl.call("gen_new_pc");
}

export { decode, fetch, execute, memory, writeBack, updatePC }