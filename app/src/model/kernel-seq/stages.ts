import {Sim} from "./sim"
import {registers_enum} from "./registers"
import {Memory} from "./memory"
// Used at compile-time and for unit tests
import * as hcl from "./hcl"
import {simStatus} from "../status";

function fetch(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    sim.context.pc = sim.context.newPC;
    sim.context.valP = sim.context.pc;
    try {
        let byte = sim.memory.readByte(sim.context.valP);
        sim.context.valP++;

        sim.context.icode = Memory.HI4(byte);
        sim.context.ifun = Memory.LO4(byte);
    }
    catch (e) {
        sim.errorMessage = e;
        sim.status = simStatus.ADDR;
        return;
    }

    hcl.setCtx({
        icode: sim.context.icode,
        ifun: sim.context.ifun
    });

    if(!hcl.call( "instr_valid")) {
        sim.status = simStatus.INSTR;
        sim.errorMessage = "Invalid Instruction encountered";
        return;
    }

    if (sim.context.icode == 0 || sim.context.icode == 1){
        sim.status = simStatus.HALT;
        return;
    }

    if(hcl.call("need_regids")) {
        try {
            let byte = sim.memory.readByte(sim.context.valP);
            byte = sim.memory.readByte(sim.context.valP);
            sim.context.valP++;

            sim.context.ra = Memory.HI4(byte);
            sim.context.rb = Memory.LO4(byte);
        }
        catch (e) {
            sim.errorMessage = e;
            sim.status = simStatus.ADDR;
            return;
        }
    } else {
        sim.context.ra = registers_enum.none;
        sim.context.rb = registers_enum.none
    }

    if(hcl.call("need_valC")) {
        try {
            sim.context.valC = sim.memory.readWord(sim.context.valP);
            sim.context.valP += Memory.WORD_SIZE;
        }
        catch (e) {
            sim.errorMessage = e;
            sim.status = simStatus.ADDR;
            return;
        }
    } else {
        sim.context.valC = 0
    }

}

/**
 * Decode stage. Update srcA, srcB, dstE and dstM values, depending of function generated by hcl.
 * @param sim
 */
function decode(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    hcl.setCtx({
        icode: sim.context.icode,
        ifun: sim.context.ifun,
        ra: sim.context.ra,
        rb: sim.context.rb
    });

    sim.context.srcA = hcl.call("srcA");
    if (sim.context.srcA != registers_enum.none) {
        sim.context.valA = sim.registers.read(sim.context.srcA);
    }
    else {
        sim.context.valA = 0;
    }

    sim.context.srcB = hcl.call("srcB");
    if (sim.context.srcB != registers_enum.none) {
        sim.context.valB = sim.registers.read(sim.context.srcB);
    }
    else {
        sim.context.valB = 0;
    }

    sim.context.dstE = hcl.call("dstE");
    sim.context.dstM = hcl.call("dstM");
}

/**
 * Execute stage. Call alu_compute function.
 * @param sim
 */
function execute(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    hcl.setCtx({
        icode: sim.context.icode,
        ifun: sim.context.ifun,
        vala: sim.context.valA,
        valb: sim.context.valB,
        valc: sim.context.valC
    });
    sim.context.aluA = hcl.call("aluA");
    sim.context.aluB = hcl.call("aluB");
    let alu_fun = hcl.call("alufun");

    // compute in valE from aluA and aluB
    try {
        sim.context.valE = sim.alu.compute_alu(sim.context.aluA, sim.context.aluB, alu_fun);
    }
    catch (e) {
        sim.status = simStatus.HALT;
        sim.errorMessage = e;
    }

    // Set flags
    if (hcl.call("set_cc")) {
        sim.alu.compute_cc(sim.context.aluA, sim.context.aluB, alu_fun);
    }

    // bcond flag
    if (hcl.call("is_bch")){
        sim.context.bcond = sim.alu.compute_bch(sim.context.ifun);
    }
    else {
        sim.context.bcond = false;
    }
}

/**
 * Memory stage. Decide whenever it need to write or read in memory. Both can't be done in one cycle in this
 * implementation of the y86.
 * @param sim
 */
function memory(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    hcl.setCtx({
        icode: sim.context.icode,
        ifun: sim.context.ifun,
        vale: sim.context.valE,
        vala: sim.context.valA,
        valp: sim.context.valP
    });

    let mem_addr = hcl.call("mem_addr");
    let mem_data = hcl.call("mem_data");

    if (hcl.call("mem_read")) {
        try {
            sim.context.valM = sim.memory.readWord(mem_addr);
        }
        catch (e) {
            sim.status = simStatus.ADDR;
            sim.errorMessage = e;
            return;
        }
    }

    else if (hcl.call("mem_write")) {
        try {
            sim.memory.writeWord(mem_addr, mem_data);
        }
        catch (e) {
            sim.status = simStatus.ADDR;
            sim.errorMessage = e;
            return;
        }
    }
}

/**
 * Write back stage. Uses dstE to find the register where to write the value in valE. Same for dstM.
 * Only if the register stored in dstE and/or dstM is not the special register 'none'.
 *
 * dstM and dstE were previously assigned in decode stage.
 * @param sim
 */
function writeBack(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    if (sim.context.dstE != registers_enum.none) {
        let valE = sim.context.valE;
        sim.registers.write(sim.context.dstE, valE);
    }

    if (sim.context.dstM != registers_enum.none) {
        let valM = sim.context.valM;
        sim.registers.write(sim.context.dstM, valM);
    }
}

function updatePC(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    hcl.setCtx({
        icode: sim.context.icode,
        ifun: sim.context.ifun,
        valc: sim.context.valC,
        valm: sim.context.valM,
        valp: sim.context.valP,
        bcond: sim.context.bcond
    });
    sim.context.newPC = hcl.call("new_pc");
}

export { decode, fetch, execute, memory, writeBack, updatePC }